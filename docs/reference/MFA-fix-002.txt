You are an expert Full-Stack Developer specializing in Next.js, Supabase authentication (including MFA/2FA implementation), and Vercel deployment. Your primary goal is to diagnose and provide a precise solution for a recurring loop issue during the second-factor authentication process for Super Admins.

The application stack is:
- Frontend/Framework: Next.js
- IDE: Cursor IDE
- Backend/Database: Supabase
- Hosting: Vercel
- Authentication: Supabase Auth Component

The issue occurs specifically when a user with the 'superadmin' role attempts to log in:
1. Basic authentication succeeds.
2. The application correctly identifies the role as 'superadmin' and redirects to the MFA challenge.
3. The user enters a valid code from their Google Authenticator.
4. The MFA challenge is accepted (the code is verified).
5. Immediately after acceptance, the page flashes, and the user is redirected back to the *same* MFA challenge, creating an infinite loop where the second factor cannot be completed.

The core task is to identify the likely cause of this immediate re-prompting after successful MFA verification and provide actionable steps to resolve the infinite MFA loop for Super Admins using Supabase MFA.
***********************************
Claude Sonnet 4.5 Response

Diagnosis and Solution for Supabase MFA Infinite Loop
Root Cause Analysis

This infinite loop typically occurs due to session state mismanagement after successful MFA verification. The most common causes are:

Session not being properly established after MFA verification
Middleware or auth guards re-checking auth state before session cookies are set
Race condition between session establishment and redirect
Missing or incorrect session refresh after MFA challenge completion

Step-by-Step Solution
1. Verify MFA Challenge Completion Code

Your MFA verification handler should look like this:

// app/mfa-challenge/page.tsx or pages/mfa-challenge.tsx

import { useState } from 'react'
import { useRouter } from 'next/navigation' // or 'next/router' for pages directory
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'

export default function MFAChallenge() {
  const [code, setCode] = useState('')
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)
  const router = useRouter()
  const supabase = createClientComponentClient()

  const handleMFAVerification = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    setError('')

    try {
      // Get the current challenge ID from the session
      const { data: { session }, error: sessionError } = await supabase.auth.getSession()
      
      if (sessionError) throw sessionError
      
      // Verify the MFA code
      const { data, error: verifyError } = await supabase.auth.mfa.verify({
        factorId: session?.user?.factors?.[0]?.id!, // Get the factor ID
        challengeId: session?.user?.aal1_challenge_id!, // Critical: use the challenge ID
        code: code.replace(/\s/g, ''), // Remove any spaces
      })

      if (verifyError) throw verifyError

      // CRITICAL: Wait for session to be fully established
      await new Promise(resolve => setTimeout(resolve, 500))

      // Refresh the session explicitly
      const { data: { session: newSession }, error: refreshError } = 
        await supabase.auth.refreshSession()

      if (refreshError) throw refreshError

      // Verify AAL2 is achieved
      if (newSession?.user?.aal !== 'aal2') {
        throw new Error('MFA verification succeeded but AAL2 not achieved')
      }

      // Force a hard navigation to avoid state issues
      window.location.href = '/dashboard' // Use window.location instead of router.push
      
    } catch (err: any) {
      console.error('MFA verification error:', err)
      setError(err.message || 'Invalid verification code')
      setLoading(false)
    }
  }

  return (
    // Your form JSX
  )
}

2. Fix Middleware to Respect MFA State

This is often the primary culprit. Your middleware must not redirect users who have completed MFA:

// middleware.ts

import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })

  const {
    data: { session },
  } = await supabase.auth.getSession()

  const path = req.nextUrl.pathname

  // Allow public routes
  if (path === '/login' || path === '/signup') {
    if (session) {
      return NextResponse.redirect(new URL('/dashboard', req.url))
    }
    return res
  }

  // No session at all - redirect to login
  if (!session) {
    return NextResponse.redirect(new URL('/login', req.url))
  }

  // CRITICAL: Check if user needs MFA but hasn't completed it
  const userRole = session.user.user_metadata?.role || 
                   session.user.app_metadata?.role

  // User needs MFA (superadmin) but hasn't achieved AAL2
  if (userRole === 'superadmin' && session.user.aal !== 'aal2') {
    // Only redirect to MFA if not already there
    if (path !== '/mfa-challenge') {
      return NextResponse.redirect(new URL('/mfa-challenge', req.url))
    }
    // If already on MFA page, allow access
    return res
  }

  // User on MFA page but has already completed MFA (AAL2 achieved)
  if (path === '/mfa-challenge' && session.user.aal === 'aal2') {
    return NextResponse.redirect(new URL('/dashboard', req.url))
  }

  // All checks passed
  return res
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}

3. Update Login Handler

Ensure your initial login properly handles MFA enrollment status:

// app/login/page.tsx

const handleLogin = async (email: string, password: string) => {
  try {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) throw error

    const userRole = data.user?.user_metadata?.role || 
                     data.user?.app_metadata?.role

    // Check if user has MFA enrolled
    const { data: factors } = await supabase.auth.mfa.listFactors()
    const hasMFA = factors && factors.totp && factors.totp.length > 0

    if (userRole === 'superadmin' && hasMFA) {
      // Create MFA challenge
      const { data: challengeData, error: challengeError } = 
        await supabase.auth.mfa.challenge({
          factorId: factors.totp[0].id
        })

      if (challengeError) throw challengeError

      // Redirect to MFA challenge page
      router.push('/mfa-challenge')
    } else if (userRole === 'superadmin' && !hasMFA) {
      // Redirect to MFA enrollment
      router.push('/mfa-enroll')
    } else {
      // Regular user - go to dashboard
      router.push('/dashboard')
    }
  } catch (err) {
    console.error('Login error:', err)
  }
}

4. Add Session Persistence Check

Create a utility to verify session state:

// lib/auth-utils.ts

import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'

export async function verifyMFACompletion() {
  const supabase = createClientComponentClient()
  
  // Wait a bit for session to propagate
  await new Promise(resolve => setTimeout(resolve, 300))
  
  const { data: { session }, error } = await supabase.auth.getSession()
  
  if (error) {
    console.error('Session verification error:', error)
    return false
  }
  
  // Verify AAL2 is achieved
  const isAAL2 = session?.user?.aal === 'aal2'
  console.log('MFA Verification Status:', {
    aal: session?.user?.aal,
    isAAL2,
    userId: session?.user?.id
  })
  
  return isAAL2
}

Use this in your MFA challenge component:

// After successful verification
const isVerified = await verifyMFACompletion()

if (isVerified) {
  window.location.href = '/dashboard'
} else {
  setError('Session not properly established. Please try again.')
}

5. Supabase Client Configuration

Ensure your Supabase client is properly configured for cookie-based auth:

// app/supabase-provider.tsx (for App Router)

'use client'

import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { useRouter } from 'next/navigation'
import { createContext, useContext, useEffect, useState } from 'react'

const SupabaseContext = createContext(undefined)

export default function SupabaseProvider({ children }) {
  const [supabase] = useState(() => createClientComponentClient())
  const router = useRouter()

  useEffect(() => {
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((event, session) => {
      console.log('Auth state changed:', event, session?.user?.aal)
      
      // Refresh the router to update server components
      if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
        router.refresh()
      }
      
      // Handle MFA completion
      if (event === 'MFA_CHALLENGE_VERIFIED') {
        console.log('MFA verified, AAL:', session?.user?.aal)
        // Small delay to ensure session is saved
        setTimeout(() => {
          router.refresh()
        }, 500)
      }
    })

    return () => {
      subscription.unsubscribe()
    }
  }, [router, supabase])

  return (
    <SupabaseContext.Provider value={supabase}>
      {children}
    </SupabaseContext.Provider>
  )
}

6. Debug Logging

Add comprehensive logging to identify the exact failure point:

// Add to your MFA challenge page

useEffect(() => {
  const checkAuthState = async () => {
    const { data: { session } } = await supabase.auth.getSession()
    console.log('Current Auth State:', {
      aal: session?.user?.aal,
      hasMFA: session?.user?.factors?.length > 0,
      path: window.location.pathname,
      timestamp: new Date().toISOString()
    })
  }
  
  checkAuthState()
}, [])

Testing Checklist

After implementing these fixes:

✅ Clear all browser cookies and localStorage
✅ Log in as superadmin
✅ Complete MFA challenge
✅ Verify console logs show aal: 'aal2'
✅ Confirm redirect to dashboard occurs
✅ Refresh the page - should stay on dashboard
✅ Check Network tab for any 307/308 redirects in a loop

Common Pitfalls to Avoid

Using router.push() instead of window.location.href after MFA - this can cause state issues
Not waiting for session propagation - add small delays after verification
Middleware checking auth before cookies are set - ensure middleware respects MFA state
Not refreshing session after MFA verification - always call refreshSession()
Checking wrong AAL level - verify session.user.aal === 'aal2' not just session existence

If Issue Persists

If the loop continues, provide:

Console logs from the MFA challenge page
Network tab showing the redirect sequence
Your current middleware.ts code
Your MFA challenge component code

This will allow for more targeted debugging.





